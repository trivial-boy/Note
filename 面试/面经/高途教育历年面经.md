### 用redis做二级缓存的时候如何确保高并发数据的一致性

需要尽可能保证缓存与数据库的最终一致性，应该选择合适的缓存更新策略

目前最类型的缓存读写策略cache-aside-pattern 采用先更新数据库，再删缓存的方式。但这种策略还是会可能产生数据不一致问题，例如缓存删除失败

缓存不一致处理

如果不是并发特别高，对缓存依赖性很强，其实一定程序的不一致是可以接受得。

如果非要确保高一致性，可以加上重试机制。如果缓存删除失败加删除缓存的操作缓存进消息队列，不断重试。也可以订阅mysql的binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。

### 数据库的事物隔离级别机制？有什么作用？怎么实现？

1. 读未提交 （Read Uncommitted）

   事物可以读到其他事物未提交的数据

   原理：

   - 事物读不加锁，不阻塞其他事物的读和写
   - 事物写阻塞其他事物写，但不阻塞其他事物读

2. 读已提交 （Read Committed）

   事物只能可以读到其他事物提交的数据

   原理：

   - 读取已提交使用ReadView和MVCC，也就是每个事物只能读取它能看到的版本（ReadView）
   - 每次读取数据前都生成一个ReadView

3. 可重复读 （Repeatable Read）

​		在读已提交的情况下，可解决不可重复读的问题。

​		原理：

​		读数据时使用ReadView和Mvcc，在每一次读取数据时生成一个ReadView，每个事物只能读取它能看到的版本（ReadView）。

​		写数据时使用排他锁。

4. 串行化 （Serialzable）

​		串行化的实现采用的是读写都加锁的原理。

​		串行化的情况下，对于同一行事物，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事物必须等前一个事物执行完成，才能继续执行。

读已提交和可串行化都是在事物开始时创建一个ReadView，然后遍历版本链表，找到

### MVCC 怎么实现的？

MVCC 是多版本并发控制，简单来说通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。

#### 版本链

InnoDB引擎的记录中都包含 **trx_id**和 **roll_pointer** 两个隐藏列。

trx_id ：一个事物对某条聚簇索引记录进行改动时，都会把该记录的事物id赋值给trx_id

roll_pointer: 每次对某条聚簇索引记录进行改动时，对会把旧的版本写入到undo日志中，roll_pointer是该记录的指针。

每对记录进行一次改动，都会记录一条undo日志（记录改动之前的旧值）。每条undo日志也都有一个roll_pointer属性（insert没有）。通过这个属性可以将这些undo日志串成一个链表。这个链表被称为版本链，版本链的头节点就是当前记录的最新值。另外，每个版本中还包含生成该版本时对应的事物id。我们通过它就可以实现多版本并发控制（mvcc）。

#### ReadView

对于Read Committed 和 Repeatale Read 隔离级别来说，都需要读取已经提交的事物所修改的记录，也就是说如果版本链中每个版本的修改没有提交，那么该版本的记录时不能被读取的。所以需要确定在`Read Commited` 和 `Repeatable Read` 隔离级别下，版本链中哪个版本是能被当前事物读取的。于是就引入了`ReadView`这个概念来解决这个问题。

ReadView 就是事物执行快照读时，产生的读视图，相当于某时刻记录的一个快照，通过这个快照，可以获取

- m_ids：表示在生成ReadView时当前系统中活跃的读写事物的事物id列表。
- min_trx_id: 表示在生成ReadView时当前系统中活跃的读写事物中最小的事物id，也就是m_ids中的最小值。
- max_trx_id:表示生成ReadView时系统应该分配给下一个事物的id值。
- creator_trx_id: 表示生成该ReadView的事物的事物id。

有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。

- 如果访问版本 trx_id 属性值与ReadView 中的creator_trx_id 相同，意味当前事物在访问它自己修改过的记录，所以该版本可以被当前事物访问。
- 如果访问版本trx_id属性值小于ReadView 中的min_trx_id值，表明生成该版本的事物在当前事物生成ReadView前已经提交，所以该版本可以被当前事物访问。
- 如果被访问版本的trx_id属性值大于ReadView 中的 max_trx_id 值，表明生成该版本的事物在当前事物生成ReadView后才开启，所以该版本不可以被当前事物访问。
- 如果被访问版本的trx_id属性值在ReadView的min_trx_id 和max_trx_id 之间，那就需要判断一下trx_id 属性值是不是在m_ids中，如果在说明事物还在活跃中，不能被访问，如果不在，证明事物已提交可以访问。

Read Committed 每次读取数据之前都生成一个ReadView,这样就能保证每次读取到其他事物提交的数据。REPEATABLE READ 是在第一次读取数据时生成一个ReadView ，这样就能保证后续读取的结果完全一致。 

### Str1=“a” str2=new string(“a”)区别，虚拟机内存空间上如何体现这两个区别，这区别具体在哪？开发中会造成什么问题，如何解决？

Str1在编译时创建储存在字符串池中，str2会通过构造函数创建出一个新的字符串对象，将在堆内存分配一块新的空间。在字符串池中，相同值的字符串对象只会被存储一次。

使用new手动创建字符串对象时，不管字符串常量池有没有相同的字符串对象，都会新创建一个字符。

开发中会如果使用== 来比较str1和str2的会返回false

频繁的使用new操作字符串对象，会导致内存占用率增加导致系统性能下降。所以应该注意字符串对象的创建和销毁，合理利用字符串常量池，尽量减少字符串对象的创建。

解决方案：

1. 尽量使用字面值方式创建字符串对象
2. 使用字符串常量池来管理字符串对象，调用String类的intern方法，将手动创建的字符串添加到字符串常量池中。
3. 对于可变的字符尽量使用StringBuilder 或StringBuffer来代理手动创建字符串对象，避免频繁创建和销毁字符串对象。

### jvm 常用的垃圾回收机制？什么时候会发生OOM

#### 常用垃圾回收机制

1. 标记-清除算法

   标记已使用的对象，然后清除未标记的对象，容易产生垃圾碎片

1. 标记-整理算法

   标记已使用的对象，将存活的对象移动到内存的一端，然后清除未使用的对象，避免了内存碎片的问题。

2. 复制算法

   将内存划分为两部分，一部分是已使用的对象，另一部分是未使用的对象，每次垃圾回收时将已使用的对象复制到未使用的对象区域，清除已使用的对象区域。

3. 分代收集算法

该算法将对象分为新生代和老年代两个部分，新生代的对象生命周期短，垃圾回收频率高，而老年代的生命周期较长，垃圾回收频率较低。

#### 发生OOM的情况

虚拟机规范里指出除了程序计数器，其他内存都可能会产生oom

1. 堆内存溢出

   java.lang.OutOfMemoryError: Java heap space ------>堆内存溢出：堆内存没有可用空间给新对象分配内存，有可能是内存泄漏造成的。

2. 虚拟机栈和本地方法栈溢出

   - 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常
   - 如果虚拟机在扩展栈时无法申请足够的空间，会抛出OutOfMemoryError异常。

3. 方法区和运行时常量池溢出

   方法区用于存放Class相关信息，当前很多主流框架 如Spring、Hibernate，在对类进行增强时，会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区保证动态生成的Class可以加载到内存。

4. 直接内存溢出

   java允许·应用程序通过Direct ByteBuffer直接访问堆外内存，许多高性能程序通过Direct ByteBuffer结合内存映射文件实现高速IO。

   Direct ByteBuffer 的默认大小为 64 MB，一旦使用超出限制，就会抛出 Directbuffer memory 错误。

### Redis的基本数据结构

五种基本数据结构

#### String

最基础的数据结构。可以使字符串、数字，甚至是二进制，但值不能超过512M。

应用场景：

- 缓存Json序列化后的对象
- 计数
- 限速

#### set

Set集合用来保存多个字符串元素，但和列表不同，集合不允许有重复元素，且集合是无序的。、

集合使用场景：

- 标签
- 去重

#### sorted Set

有序集合中的元素可以排序。但它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据

使用场景：

- 用户点赞统计
- 用户排序

#### hash

键值对结构

使用场景：

- 缓存用户信息
- 缓存对象

#### list

用来存储多个有序的字符串。列表是一种比较灵活的数据结构，可以充当栈和队列

使用场景：

- 消息队列
- 文章列表

### Redis是如何做持久化的

Redis持久化方案分为RDB和AOF两种

#### RDB做全量持久化

RDB是将Redis中所有数据生成快照并以二进制分方式保存到硬盘中。

RDB持久化的方法有rdbSave和rdbSaveBackground两种方式：

rdbSave：同步执行，方法调用后立刻启动持久化流程。由于Redis是单线程模型，持久化会阻塞，Redis无法对外提供服务

rdbSaveBackground：是后台执行的，该方法会fork出子进程，真正的持久化过程是在子进程中执行的，主进程会继续提供服务。也就是异步进行的。

优点：

- 只有一个文件dump.rdb,方便持久化
- 
- RDB是一个紧凑压缩的二进制文件，RDB重启时的加载效率比AOF持久化更高。

缺点: 

- 不够实时，如果redis宕机会丢失大量数据。
- 由于RDB是通过fork子进程来协助完成数据持久化，如果当数据集较大时，可能会导致整个服务器间歇性暂停服务。

#### AOF做增量持久化

AOF是以日志形式记录每个写操作，将redis执行过得所有写操作指令记录下来。

只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写操作从前到后执行一次完成数据的恢复工作。

AOF同步有三种策略：

- 修改同步

  发生写命令都会写入aof文件，并通过事件循环磁盘同步，即使Redis意外宕机，最多只丢失一事件循环内的执行的数据。

- 每秒同步

  每一秒写入aof文件，并完成磁盘同步，发生宕机，最多丢失一秒数据

- 不主动调用fsync同步

  服务器不主动调用fsync同步，由操作系统决定何时将缓冲区里面的命令写入到硬盘里，这种模式下

优点：





