# ThreadLocal的内存泄露？什么原因？如何避免？

## 内存泄露

内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光，

广义并通俗的说，就是：不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。

## 强引用与弱引用

**强引用**，使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。

**如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。**

**弱引用**，JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。



# 进程与线程的区别

1. 进程：系统运行程序运行的基本单位。
2. 线程：是比进程更小的执行单位，一个进程执行可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，每个线程都有自己的程序计数、虚拟机栈和本地方法栈，所以系统产生一个线程，或在线程之间切换时比进程的负担小很多。

# 请简要描述以下线程与进程的关系，区别和优缺点

以JVM为例，一个jvm进程里面可能包含多个线程，多个线程共享jvm进程的堆和方法区资源，但每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。

线程与进程最大的不同在于基本上各进程是相互独立的，而各线程不一定，因为同一进程中的线程极有可能相互影响。线程执行开销小，不利于资源换的管理和保护。进程相反。

# 并发与并行的区别

并发：多个作业在**同一时间段内**进行

并行：多个作业在**同一时刻**执行。

# 同步和异步的区别

同步：系统发出一个调用必须等到返回结果才算结束

异步：系统发出一个调用直接结束，不用等到返回结果。

# 线程的声明周期和状态

6 个状态

- new ：初始状态，线程被创建出来但没有被调用 start
- RUNNABLE: 运行状态，线程调用了 start 等待运行的状态
- BLOCKED：阻塞状态，需要等待锁释放
- WAITING：等待状态，表示该线程需要等待其他线程一些特定动作（通知或者中断）
- TIME_WAITING: 超时等待状态，可以在指定的时间后自行返回而不是像WAITING那样一直等待。
- TERMINATED：终止状态，表示该线程已经运行完毕。

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换

![image-20230202145810331](https://img.trivial.top/img/image-20230202145810331.png)

# 什么是线程死锁？如何避免死锁

A 线程持有资源2 ，B线程持有资源1，他们同时都想申请对方的资源，这两个线程就会相互等待进入死锁。

```java
 		Object resource1 = new Object();
        Object resource2 = new Object();

        new Thread(() -> {
            synchronized (resource1) {
                try {
                    System.out.println(Thread.currentThread() + "get resource1");
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }).start();

        new Thread(() -> {
            synchronized (resource2) {
                try {
                    System.out.println(Thread.currentThread() + "get resource2");
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }).start();
```

产生死锁的四个条件

1. 互斥：该资源任意一刻只能由一个线程占用
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才能释放资源。
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。



# 如何避免和预防死锁

## 如何预防？

1. 破坏请求与保持条件：一次性申请所有资源
2. 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放自己持有的资源
3. 破坏循环等待条件：靠按1序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。

## 如何避免死锁？

避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

> **安全状态** 指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 `<P1、P2、P3.....Pn>` 序列为安全序列。

# sleep() 和 wait ()对比

区别：

- sleep 方法没有释放锁，而wait 方法释放了锁。
-  wait() 通常被用于线程间通信
- wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象的notify() 或者 notifyAll() 方法。sleep() 方法执行后，线程会自动苏醒.
- sleep() 是 Thread 类的静态本地方法，wait() 则是Object 类的本地方法。

# 为什么wait() 方法不定义在Thread 中?

wait() 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象(Object) 都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，自然是要操作对象而非当前的线程。

类似的问题：**为什么 `sleep()` 方法定义在 `Thread` 中？**

sleep 是为了让当前线程暂停执行，不涉及对象类，不需要获得对象锁。

# volatie 关键字

## 如何保证变量的可见性？

**什么是可见性:**  被volatile 关键字修饰的共享变量发生修改时会立即更新到主存中，有其他线程需要读取时，从内存中读取的是新值。就是说共享变量的修改对其他线程是可见的，不会发生修改后因未来的及同步到主存中，读取到修改前的值。

在java中，volatile 关键字可以保证变量的可见性，将变量声明为volatile，这就指示jvm，这个变量是共享且不稳定的，每次使用它都到主存中进行读取

## 如何禁止指令重排？

在java中，**volatile 关键字处理可以保证变量的可见性，还有一个重要的作用就是防止JVM的指令重排**。如果我们将变量声明为volatile，在对这个变量进行读写操作时，会通过插入特定的**内存屏障**的方式来禁止指令重排。



# synchronized 关键字

## 如何使用

主要使用方式分为下面三种：

1. 修饰实例方法 (锁当前对象实例)
2. 修饰静态方法 （所当前类）

​	静态成员不属于任何一个实例对象，归整个类所有，不依赖类的特定实例，被类的所有实例共享。

​	静态 `synchronized`方法和非静态 `sychronized`方法之间的调用互斥吗？不互斥 ，锁的对象不一样

1. 修饰代码块  （锁定）

对括号里指定的对象/类加锁

- `synchronized(object)` 表示进入同步代码块前要获得给定对象的锁
- synchronized(类.class) 表示进入同步代码块前要获得给定Class的锁。

**总结**

- `synchronized` 关键字加到`static` 静态方法 和 synchronized(class) 代码块都是给Class类上锁
- `synchronized`关键字加到实例方法上是给对象实例上锁。
- 尽量不要使用 `synchronized(String a)` 因为JVM中，字符串常量具有缓存功能。

 ## 构造方法可以使用synchronized的修饰吗

不能，构造方法本身就属于线程安全的，不存在同步的构造方法。

## synchronized 底层原理

synchronized 同步语句块的实现使用的是 monitorenter 和

