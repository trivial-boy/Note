---
title：JVM相关面试题
date: 2023/2/20 20:15
---

## JVM 内存划分

粗略划分可以分为`堆`和`栈` ,按照虚拟机规范，可以划分为以下几个区域

### 程序计数器

作用：

- 记录当前线程执行的位置
- 实现代码流程控制

### 虚拟机栈

- 栈帧：

  - 局部变量表

    存放方法内的临时变量

  - 动态链接

    存放方法的引用，编译时期方法引用会作为符号引用存放在Class文件的常量池里，当发生方法调用时，会将常量池的符号引用转换为直接引用，动态链接就记录的是方法的直接引用。（具体是方法区运行时常量池的方法引用）

  - 操作数栈

    主要作为方法调用的中转站，存放方法执行过程中产生的中间计算结果。

    计算产生的临时变量也会存放在这

  - 方法返回地址

### 本地方法栈

### 堆

作用：存放对象实例，GC管理的内存区域

包含：字符串常量池

按照GC机制来划分分为：

- 新生代：
  - Eden  
  - From suvivor 0  
  - To suvivor 1  

- 老年代

### 方法区

作用：存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

注意：JDK1.7 方法区的实现是堆的永久代，JDK1.8方法区的实现是元空间

包含：运行时常量池

### 补充

此外除了虚拟机规范的5大区域外，在jvm中还有两个常量1池，

#### 运行时常量池

​		作用：类编译后的常量池表(存放了编译期间产生的各种字面量和符号引用)在类加载后会进入方法区的运行时常量池。

​		位置：存放在方法区中

#### 字符串常量池

​		作用：为了提升性能专门为字符串开辟的区域，其中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。

​		位置：存放在堆中 

​	 	扩展：[字符串常量生成的时机](https://blog.csdn.net/Prior_SX/article/details/123463430)

#### 直接内存

​		直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的区域。

​		是JDK 1.4 中新加入的NIO 类，引入了一种基于 通道与缓存区的I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储到java堆中的DirectByteBuffer 对象作为内存的引用进行操作。这样就能在一些场景中显著提高性能。因为避免了再java堆和Native堆之间来回复制数据。



![image-20230220101121825](https://img.trivial.top/img/image-20230220101121825.png)



## 对象的创建过程

### 创建步骤

#### Step 1： 类加载检查

从new指令开始，检查这个指令的参数能否在常量池中定位到一个符号引用

检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有则执行响应的类加载过程。

#### Step 2： 分配内存

虚拟机为新生对象分配内存。（内存在类加载完成就可以确定）

分配方式有**指针碰撞**和**空闲列表** ，**选择哪种由堆是否规整决定，是否规整又由采用的垃圾收集器是否带有压缩整理功能决定。**

#### Step 3：初始化零值

虚拟机将分配到的内存空间都初始化为零值。（不包括对象头）

#### Step 4：设置对象头

初始化零值后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，对象的hash码，对象的GC年龄分代等信息。对象头就存放着这些信息。

#### Step 5：执行init方法

从虚拟机视角来看第四步对象已经创建好，但对象实例还没有执行`<init>`方法（即按照程序员意愿给对象中的变量赋值）。

### 对象的分配方式

#### 指针碰撞

- 原理：用过的内存全部整合到一遍，没用的内存放在另一边，中间有一个分解指针，只需要向着没有过的内存区域移动对象内存大小的位置即可。
- 使用场合：堆规整的情况下。
- 使用该分配方式的GC收集器：Serial，ParNew

#### 空闲列表

- 原理：虚拟机会维护一个列表，列表中会记录哪些内存是可用的，分配的时候，找一块足够大的内存块划分给对象实例，然后更新列表记录。
- 适用场合：堆不规整
- 使用该分配方式的GC收集器：CMS

### 虚拟机如何保证对象创建过程中是线程安全的

- CAS + 失败重试：CAS是乐观锁的一种实现方式。
- TLAB：为每一个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，有现在TLAB分配，不够了在使用CAS进行分配。

### 对象的内存布局

主要分为三块区域：**对象头、实例数据和对齐填充**

**对象头**

HotSpot虚拟机的对象头主要包块两部分信息：

- **一部分用于存储对象自身的运行时数据** （0哈希码、GC 分代年龄、锁状态标志等等）
- **一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个来确定这个对象是哪个类的实例。

**实例数据**

实例数据部分是对象真正存储的有效信息。

**对齐填充**

仅起到占位作用。因为 HotSpot 虚拟机的自动内存管理系统要求对象的其实地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍。对象头正好是8字节的倍数（1倍或2倍），因此如果实力数据部分没有对齐时，需要通过对齐填充来补全。

## 对象的访问定位

对象的访问定位方式由 虚拟机实现而定，目前主流的方式有：**使用句柄、直接指针**

### **句柄**

如果使用句柄，java堆中会划分一块区域作为句柄池，refrence中存储的就是对象的句柄地址，而句柄中包含了 **==对象实例数据== 与 ==对象类型数据== 各自的具体地址信息**。

![image-20230220160541720](https://img.trivial.top/img/image-20230220160541720.png) 

### **直接指针**

如果使用直接指针访问，reference中存储的指针就是对象的地址

![对象的访问定位-直接指针](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png)





##  垃圾回收详解

###  根据GC机制堆内存的分布

JDK 7 版本及 之前，堆内存通常分为下面三部分

1. 新生代内存
2. 老年代
3. 永久代

下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。

 ![hotspot-heap-structure](https://javaguide.cn/assets/hotspot-heap-structure.41533631.png)

JDK 8 之后 ，取消永久代

### 内存的分配过程

#### 1 .  对象首先在Eden 区分配

大多数情况下，对象在新生代的Eden区分配内存。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

#### 2.  大对象直接进入老年代

大对象就是需要大量连续内存空间的对象（如：字符串、数组）

#### 3.  长期存活的对象进入老年代

大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。

对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

#### 4. 动态年龄判断

HotSpot 虚拟机并不是永远要求对象年龄达到`-XX:MaxTenuringThreshold` 才能晋升老年代。如果Survivor空间中**相同年龄所有对象**大小的总和大于**Survivor空间的一半**，年龄大于该年龄的对象就会直接进入老年代。

#### 5. 空间分配担保

**什么是分配担保：**

Eden区域存活下来的对象需要复制到suvior区，但Eden区大于suvior区，suvior区域的内存可能不够，需要依赖其他内存区域(实际上大多数是老年代)进行分配担保。如果一次Minor GC 之后存活的对象大于一块Survivor空间时，这些对象将通过分配担保直接进入老年代。

JDK 1.6之前 在发生Minor GC 之前，虚拟机必须检查**老年代的最大可用空间**是否大于**新生代所有对象总空间**，如果成立，则MinorGC确保是安全的。如果不成立会检查参数是否运行担保，如果允许则继续检查**老年代最大可用空间是否大于历次晋升到老年代对象的平均大小**，如果成立，进行Minor GC（这次是有风险的）

JDK1.6 Update24 之后规则只要**老年代的连续空间**大于**新生代对象总大小或者历次晋升的平均大小**，就会进行Minor GC，否则进行Full GC;

**为什么是 新生代对象总大小或者历次晋升的平均大小 ?**

因为：在每次Minor GC 之前无法确认到底多少对象存活下来了，只能直接用新生代对象总大小或者历次晋升的平均大小来估计。

### 主要进行GC的区域

主要分为部分收集(Partial GC) 和 整堆收集 (Full GC)

Partial GC : 

新生代收集（Minor GC / Young GC） 只对新生代进行收集

老年代收集 ( Major GC / Old GC) 只对老年代收集

混合收集 （Mixed GC） ：对整个新生代和部分老年代进行收集（只有G1 收集器有这个模式）

### **GC触发条件**

不同收集器触发条件不同，按照HotSPot VM的serial GC实现来看，触发条件是：

- young GC： 当young gen中的eden区分配满的时候触发。

- full GC : 

  - 如果之前young GC平均晋升大小比old Gen空间大的时候，会触发Full GC。
  - YoungGC之后老年代空间不足：Young 之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象，此时必须立即触发一次Full GC。
  - **如果空间分配担保失败**（也就是说，空间分配担保条件通过，但old Gen空间不足以分配yong GC 的大小）则也会触发Full GC。
  - **老年代空间不足：**老年代内存使用率过高，到达一定比例，会触发Full GC。
  - **方法区内存空间不足**：如果方法区由永久代实现，永久代空间不足触发Full GC。
  - System.gc()等命令触发

  ![image-20230220165515424](https://img.trivial.top/img/image-20230220165515424.png)

## GC 面试问题

### 对象什么时候进入老年代

1. 长期存活的对象

   对象的对象头中存储着对象的迭代年龄，迭代年龄在每次Young Gc之后对象的移区操作中增加，每一次移区年龄加一。当这个年龄到达15 之后，这个对象会被移入老年代。

2. 大对象直接进入老年代

   连续占用大量内存空间的对象在被加载时就会直接进入老年代，这样的大对象一般是一些数组，长字符串之类的对象。

1. 动态年龄判断

   如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象会直接进入老年代。

2. 空间分配担保 

   假如在Young GC 之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代。



### 垃圾收集器

#### Serial 收集器

它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停他其他所有工作线程。



