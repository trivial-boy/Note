---
title: JVM相关面试题
date: 2023/2/20 20:15
---

## JVM 内存划分

粗略划分可以分为`堆`和`栈` ,按照虚拟机规范，可以划分为以下几个区域

### 程序计数器

作用：

- 记录当前线程执行的位置
- 实现代码流程控制

### 虚拟机栈

- 栈帧：

  - 局部变量表

    存放方法内的临时变量

  - 动态链接

    存放方法的引用，编译时期方法引用会作为符号引用存放在Class文件的常量池里，当发生方法调用时，会将常量池的符号引用转换为直接引用，动态链接就记录的是方法的直接引用。（具体是方法区运行时常量池的方法引用）

  - 操作数栈

    主要作为方法调用的中转站，存放方法执行过程中产生的中间计算结果。

    计算产生的临时变量也会存放在这

  - 方法返回地址

### 本地方法栈

### 堆

作用：存放对象实例，GC管理的内存区域

包含：字符串常量池

按照GC机制来划分分为：

- 新生代：
  - Eden  
  - From suvivor 0  
  - To suvivor 1  

- 老年代

### 方法区

作用：存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

注意：JDK1.7 方法区的实现是堆的永久代，JDK1.8方法区的实现是元空间

包含：运行时常量池

### 补充

此外除了虚拟机规范的5大区域外，在jvm中还有两个常量1池，

#### 运行时常量池

​		作用：类编译后的常量池表(存放了编译期间产生的各种字面量和符号引用)在类加载后会进入方法区的运行时常量池。

​		位置：存放在方法区中

#### 字符串常量池

​		作用：为了提升性能专门为字符串开辟的区域，其中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。

​		位置：存放在堆中 

​	 	扩展：[字符串常量生成的时机](https://blog.csdn.net/Prior_SX/article/details/123463430)

#### 直接内存

​		直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的区域。

​		是JDK 1.4 中新加入的NIO 类，引入了一种基于 通道与缓存区的I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储到java堆中的DirectByteBuffer 对象作为内存的引用进行操作。这样就能在一些场景中显著提高性能。因为避免了再java堆和Native堆之间来回复制数据。



![image-20230220101121825](https://img.trivial.top/img/image-20230220101121825.png)



## 对象的创建过程

### 创建步骤

#### Step 1： 类加载检查

从new指令开始，检查这个指令的参数能否在常量池中定位到一个符号引用

检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有则执行响应的类加载过程。

#### Step 2： 分配内存

虚拟机为新生对象分配内存。（内存在类加载完成就可以确定）

分配方式有**指针碰撞**和**空闲列表** ，**选择哪种由堆是否规整决定，是否规整又由采用的垃圾收集器是否带有压缩整理功能决定。**

#### Step 3：初始化零值

虚拟机将分配到的内存空间都初始化为零值。（不包括对象头）

#### Step 4：设置对象头

初始化零值后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，对象的hash码，对象的GC年龄分代等信息。对象头就存放着这些信息。

#### Step 5：执行init方法

从虚拟机视角来看第四步对象已经创建好，但对象实例还没有执行`<init>`方法（即按照程序员意愿给对象中的变量赋值）。

### 对象的分配方式

#### 指针碰撞

- 原理：用过的内存全部整合到一遍，没用的内存放在另一边，中间有一个分解指针，只需要向着没有过的内存区域移动对象内存大小的位置即可。
- 使用场合：堆规整的情况下。
- 使用该分配方式的GC收集器：Serial，ParNew

#### 空闲列表

- 原理：虚拟机会维护一个列表，列表中会记录哪些内存是可用的，分配的时候，找一块足够大的内存块划分给对象实例，然后更新列表记录。
- 适用场合：堆不规整
- 使用该分配方式的GC收集器：CMS

### 虚拟机如何保证对象创建过程中是线程安全的

- CAS + 失败重试：CAS是乐观锁的一种实现方式。
- TLAB：为每一个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，有现在TLAB分配，不够了在使用CAS进行分配。

### 对象的内存布局

主要分为三块区域：**对象头、实例数据和对齐填充**

**对象头**

HotSpot虚拟机的对象头主要包块两部分信息：

- **一部分用于存储对象自身的运行时数据** （0哈希码、GC 分代年龄、锁状态标志等等）
- **一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个来确定这个对象是哪个类的实例。

**实例数据**

实例数据部分是对象真正存储的有效信息。

**对齐填充**

仅起到占位作用。因为 HotSpot 虚拟机的自动内存管理系统要求对象的其实地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍。对象头正好是8字节的倍数（1倍或2倍），因此如果实力数据部分没有对齐时，需要通过对齐填充来补全。

## 对象的访问定位

对象的访问定位方式由 虚拟机实现而定，目前主流的方式有：**使用句柄、直接指针**

### **句柄**

如果使用句柄，java堆中会划分一块区域作为句柄池，refrence中存储的就是对象的句柄地址，而句柄中包含了 **==对象实例数据== 与 ==对象类型数据== 各自的具体地址信息**。

![image-20230220160541720](https://img.trivial.top/img/image-20230220160541720.png) 

### **直接指针**

如果使用直接指针访问，reference中存储的指针就是对象的地址

![对象的访问定位-直接指针](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png)



## 类加载过程

 ### 类的生命周期

一个类的完整生命周期如下：

![image-20230222092904500](https://img.trivial.top/img/image-20230222092904500.png)

### 加载

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口。

### 验证

- 文件格式验证‘

验证字节流是否符合Class文件格式的规范

- 元数据验证

对字节码描述的信息进行语义分析，确保其描述的信息符合java语言规范的要求，例如：这个类是否有父类、这个类是否继承了不允许的类。

- 字节码验证

通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，比如保证任意时刻操作数栈和指令代码序列都能配合工作

- 符号引用验证

确保解析动作能正确执行。

### 准备

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区分配**。该阶段需要注意一下几点。

1. 这时候进行内存分配的仅包括类变量，而不包括实例变量。实例变量会在对象实例化时随对象一块分配在java堆中。
2. 从概念上将，类变量所使用的内存都应当在方法区中进行分配。不过注意一点：JDK7之前，HotSpot使用





##  垃圾回收详解

###  根据GC机制堆内存的分布

JDK 7 版本及 之前，堆内存通常分为下面三部分

1. 新生代内存
2. 老年代
3. 永久代

下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。

 ![hotspot-heap-structure](https://javaguide.cn/assets/hotspot-heap-structure.41533631.png)

JDK 8 之后 ，取消永久代

### 内存的分配过程

#### 1 .  对象首先在Eden 区分配

大多数情况下，对象在新生代的Eden区分配内存。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

#### 2.  大对象直接进入老年代

大对象就是需要大量连续内存空间的对象（如：字符串、数组）

#### 3.  长期存活的对象进入老年代

大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。

对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

#### 4. 动态年龄判断

HotSpot 虚拟机并不是永远要求对象年龄达到`-XX:MaxTenuringThreshold` 才能晋升老年代。如果Survivor空间中**相同年龄所有对象**大小的总和大于**Survivor空间的一半**，年龄大于该年龄的对象就会直接进入老年代。

#### 5. 空间分配担保

**什么是分配担保：**

Eden区域存活下来的对象需要复制到suvior区，但Eden区大于suvior区，suvior区域的内存可能不够，需要依赖其他内存区域(实际上大多数是老年代)进行分配担保。如果一次Minor GC 之后存活的对象大于一块Survivor空间时，这些对象将通过分配担保直接进入老年代。

JDK 1.6之前 在发生Minor GC 之前，虚拟机必须检查**老年代的最大可用空间**是否大于**新生代所有对象总空间**，如果成立，则MinorGC确保是安全的。如果不成立会检查参数是否运行担保，如果允许则继续检查**老年代最大可用空间是否大于历次晋升到老年代对象的平均大小**，如果成立，进行Minor GC（这次是有风险的）

JDK1.6 Update24 之后规则只要**老年代的连续空间**大于**新生代对象总大小或者历次晋升的平均大小**，就会进行Minor GC，否则进行Full GC;

**为什么是 新生代对象总大小或者历次晋升的平均大小 ?**

因为：在每次Minor GC 之前无法确认到底多少对象存活下来了，只能直接用新生代对象总大小或者历次晋升的平均大小来估计。

### 主要进行GC的区域

主要分为部分收集(Partial GC) 和 整堆收集 (Full GC)

Partial GC : 

新生代收集（Minor GC / Young GC） 只对新生代进行收集

老年代收集 ( Major GC / Old GC) 只对老年代收集

混合收集 （Mixed GC） ：对整个新生代和部分老年代进行收集（只有G1 收集器有这个模式）

### **GC触发条件**

不同收集器触发条件不同，按照HotSPot VM的serial GC实现来看，触发条件是：

- young GC： 当young gen中的eden区分配满的时候触发。

- full GC : 

  - 如果之前young GC平均晋升大小比old Gen空间大的时候，会触发Full GC。
  - YoungGC之后老年代空间不足：Young 之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象，此时必须立即触发一次Full GC。
  - **如果空间分配担保失败**（也就是说，空间分配担保条件通过，但old Gen空间不足以分配yong GC 的大小）则也会触发Full GC。
  - **老年代空间不足：**老年代内存使用率过高，到达一定比例，会触发Full GC。
  - **方法区内存空间不足**：如果方法区由永久代实现，永久代空间不足触发Full GC。
  - System.gc()等命令触发

  ![image-20230220165515424](https://img.trivial.top/img/image-20230220165515424.png)

## GC 面试问题

### 对象什么时候进入老年代

1. 长期存活的对象

   对象的对象头中存储着对象的迭代年龄，迭代年龄在每次Young Gc之后对象的移区操作中增加，每一次移区年龄加一。当这个年龄到达15 之后，这个对象会被移入老年代。

2. 大对象直接进入老年代

   连续占用大量内存空间的对象在被加载时就会直接进入老年代，这样的大对象一般是一些数组，长字符串之类的对象。

1. 动态年龄判断

   如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象会直接进入老年代。

2. 空间分配担保 

   假如在Young GC 之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代。



### 垃圾收集器

重点 ：**CMS 和 G1**

#### Serial 收集器

算法：标记-复制算法

它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停他其他所有工作线程。

Serial/Serial Old 收集器的运行过程如图：

![image-20230220210121048](https://img.trivial.top/img/image-20230220210121048.png)

#### ParNew

标记-复制算法

ParNew 收集器实质是Serial收集器的多线程并行版本，使用多条线程进行垃圾收集。

![image-20230220210244969](https://img.trivial.top/img/image-20230220210244969.png)

#### Parallel Scavenge

标记-复制算法

Parallel Scanvenge 收集器基于标记-复制算法，能够并行收集。Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU 用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。

#### Serial Old

标记-整理算法

Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器。

#### Parallel Old

Parallel Old 是 Parallel Scavenger 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。

![image-20230220210759558](https://img.trivial.top/img/image-20230220210759558.png)

#### CMS收集器

介绍：CMS 收集器是一种以获取最短回收停顿时间为目标的收集器。

CMS是HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。

算法：标记-清除算法，它的运作工程相比于前面几种垃圾收集器更加复杂一些。整个过程分为四个步骤：

- 初始标记：暂停所有线程，并记录下直接与root相连的对象
- 并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的跟新引用域，所以GC线程无法保证可达性分析的实时性。
- 重新标记：重新标记阶段会为了修正并发标记期间因为用户程序运行而导致标记变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段的时间稍长。
- 并发清除：开启用户线程，同时对未标记的区域做清扫。

![image-20230220213051503](https://img.trivial.top/img/image-20230220213051503.png)

优点：并发收集、低停顿

缺点：

- 对CPU资源敏感
- 无法处理浮动垃圾
- 它使用回收算法“标记-清除”算法会导致有大量空间碎片产生。

#### G1 收集器

介绍：**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

特点：

并发与并行：G1能充分利用CPU、多核环境的优势。

分代收集：虽然G1可以不需要其他收集器配合就能管理整个GC堆，但还是保留了分代的概念

空间整合：整体上来看是“标记-整理”算法；从局部上看是基于“标记-清除”算法

可预测的停顿：G1和CMS都追求低停顿，但G1还能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。

G1收集器的运作大致分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

G1收集器在后台维护了一个筛选列表，每次根据允许的收集时间，有限选择回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内尽可能高的回收率



## JVM 调优

### 常用的命令行性能监控和故障处理工具

- 操作系统工具
  - top: 显示系统整体资源使用情况
  - vmstat: 监控内存和cpu
  - iostat：监控IO使用
  - netstat：监控网络使用
- JDK性能监控工具
  - jps：虚拟机进程查看
  - jstat: 虚拟机运行时信息查看
  - jinfo：虚拟机配置查看
  - jmap：内存映像
  - jhat：堆转储快照分析
  - jstack：java堆栈跟踪
  - jcmd：实现尚敏处理jstat所有命令的功能

### 了解哪些可视化的性能监控和故障处理工具

java自带的工具

- JConsole

- VisualVM
- Mission Control

第三方

- MAT

java堆内存分析工具

- GChisto

GC日志分析工具

- GCViewer

GC 日志分析工具

- JProfiler

商用的性能分析利器

- arthas

阿里开源诊断工具

- async-profiler

java 应用性能分析工具，开源、火焰图、跨平台

### JVM的常见参数配置知道哪些



