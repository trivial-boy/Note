## java 内置锁的核心原理

## 2.1 线程安全问题

### 自增运算不是线程安全

自增运算是一个复合操作，至少包括三个JVM指令： “内存取值” ”寄存器增加1“ ”存值到内存“。这三个指令在JVM内部是独立进行的，中间完全可能出现多个线程并发进行。

### 临界区资源与临界区代码段

java工程师在进行代码开发时，常常倾向于认为代码会以线性的、串行的方式执行，容易忽视多个线程并行执行，从而导致意向不到的结果。

临界区资源表示一种可以被多个线程使用的公共资源或共享数据，但每一次只能有一个线程使用它。一旦临界区资源被占用，想使用该资源的其他线程必须等待。

在并发情况下，临界区资源时受保护的对象。临界区代码端是每个线程中访问临界资源的那段代码，多个线程必须互斥地对临界区资源进行访问。线程进入临界区代码段之前，必须在进入区申请·资源，申请成功之后进行临界区代码段，执行完成之后释放资源。临界区代码段的进入和退出具体如图

![image-20230223215118778](https://img.trivial.top/img/image-20230223215118778.png)

## synchronized关键字

每个java对象都隐含一把锁，这里成为java内置锁。使用synchronized掉应该能相当于获取syncObject 的内置锁，所以可以使用内置锁对临界区代码段进行排他性保护。

### synchronized 同步方法

synchronized 关键字是java的保留字，当使用synchronized关键字修饰一个方法的时候，该方法被声明为同步方法，具体例子如下：

在方法声明中设置synchronized同步关键字，保证率其方法的代码执行流程是排他性的。任何时间只允许一条线程进入方法，如果其他线程都需要执行同一个方法，那么只能等待和排序。

### synchronized同步块

对于小的临界区，我们直接在方法声明设置synchronized同步关键字，可以避免竞态条件的问题。但是对于较大的临界区代码段，为了执行效率，最好将同步方法分为小的临界区代码。

### 静态同步方法

java世界里，一切皆对象。java有两种对象：Object实例对象和Class对象。每个类运行时的类信息用Class对象表示，它包含与类名称、继承关系、字段、方法有关的信息。JVM将一个类加载如自己的方法区内存时，会为其创建一个Class对象，对于一个类来说其Class对象也是唯一的。

Class类没有公共的构造方法，Class对象是在类加载的时候由java虚拟机调用类加载器中的defineClass方法自动构造的，因此不能显式地声明一个Class对象。

所有的类都是在**第一次使用时**被动态加载到JVM中，其各个类都是在必需时才加载的。这一点与许多传统语言都不同，JVM为动态加载机制配套了一个判定动态加载使能的行为，使得类加载器首先检查这个类的Class对象是否已经被加载。如果尚未加载，类加载器会根据类的全限定名查找.class文件，验证后加载到JVM的方法区内存，并构造器对应的Class对象。

## java 对象结构与内置锁

### java对象结构

不同的jvm的对象结构的实现不一样，这里以HotSpot JVM为例。

HotSpot JVM并没有将java实例对象直接一对一的映射到本地的C++对象，而是设计了一个opp-klass模型。什么是OOP模型，

